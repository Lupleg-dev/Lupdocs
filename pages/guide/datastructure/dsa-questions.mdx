# Example 1: Implementing a Stack using an Array

**Scenario:** : You are building a software that needs to handle undo operations. 
For this purpose, you need to implement a stack data structure.

**Task:** Implement a stack using an array in C++. 
Provide methods for push, pop, and peek operations.
## Example:
```cpp
#include <iostream>
using namespace std;

class Stack {
private:
    int top;
    int capacity;
    int* array;

public:
    Stack(int size) {
        capacity = size;
        array = new int[capacity];
        top = -1;
    }

    Stack() {
        delete[] array;
    }

    void push(int value) {
        if (top >= capacity - 1) {
            cout << "Stack Overflow\n";
            return;
        }
        array[++top] = value;
    }

    int pop() {
        if (top < 0) {
            cout << "Stack Underflow\n";
            return -1;
        }
        return array[top--];
    }

    int peek() {
        if (top < 0) {
            cout << "Stack is Empty\n";
            return -1;
        }
        return array[top];
    }

    bool isEmpty() {
        return top == -1;
    }
};

int main() {
    Stack stack(5);
    stack.push(10);
    stack.push(20);
    stack.push(30);

    cout << "Top element is: " << stack.peek() << endl;
    cout << "Popped element is: " << stack.pop() << endl;
    cout << "Top element is: " << stack.peek() << endl;

    return 0;
}
```
 ### Explanation:
#### Array:
- An array is a data structure that stores a fixed-size sequential collection of elements of the same type. Elements in an array are stored in contiguous memory locations, allowing efficient access via indexing.
- Arrays provide a simple way to allocate and manage memory for a collection of elements. They are ideal for scenarios where the size of the collection is known in advance and does not change dynamically.
- In this implementation, an array is used to store the elements of the stack. The array's size (capacity) is specified when the stack is initialized, and memory is allocated accordingly.

#### Stack Class:
- The Stack class uses an array to store elements. Arrays provide a contiguous block of memory, allowing efficient indexing and storage of elements.

#### Data Members:
- top: Index of the top element.
- capacity: Maximum number of elements.
- array: Dynamically allocated array.

#### Methods:
- Constructor: Initializes the stack and allocates memory.
- Destructor: Frees allocated memory.
- push(int value): Adds an element to the stack.
- pop(): Removes and returns the top element.
- peek(): Returns the top element without removing it.
- isEmpty(): Checks if the stack is empty.

#### Main Function:

- Creates a stack with capacity 5.
- Pushes elements 10, 20, and 30.
- Uses peek to show the top element.
- Uses pop to remove the top element and peek again to show the updated top element.


  # Example 2: Binary Search in a Sorted Array
  **Scenario:** You are developing a search feature for an application
  where the data is stored in sorted arrays.
  
  **Task:** Implement binary search in a sorted array in C++.
  The function should return the index of the target element if found, otherwise -1 .

 
  ```cpp
#include <iostream>
using namespace std;

int binarySearch(int array[], int size, int target) {
    int left = 0, right = size - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (array[mid] == target)
            return mid;
        if (array[mid] < target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return -1;
}

int main() {
    int array[] = {2, 3, 4, 10, 40};
    int size = sizeof(array) / sizeof(array[0]);
    int target = 10;
    int result = binarySearch(array, size, target);
    if (result != -1)
        cout << "Element found at index " << result << endl;
    else
        cout << "Element not found in array" << endl;
    return 0;
}
```

### Explanation:
-  	The binarySearch function performs binary search on the sorted array.
-   It iteratively checks the middle element and adjusts the search range based on the comparison.
-   If the target element is found, it returns the index; otherwise, it returns -1 .



# Example 3: Implementing a Queue using Linked List

**Scenario:** : You are designing a system that processes tasks in a first-come, firstserved manner. For this, you need a queue data structure.

**Task:** Implement a queue using a linked list in C++. Provide methods for enqueue, dequeue, and front operations.

## Example:
```cpp
#include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node(int value) : data(value), next(nullptr) {}
};

class Queue {
private:
    Node* front;
    Node* rear;

public:
    Queue() : front(nullptr), rear(nullptr) {}

    void enqueue(int value) {
        Node* newNode = new Node(value);
        if (rear == nullptr) {
            front = rear = newNode;
            return;
        }
        rear->next = newNode;
        rear = newNode;
    }

    int dequeue() {
        if (front == nullptr) {
            cout << "Queue Underflow\n";
            return -1;
        }
        Node* temp = front;
        front = front->next;
        if (front == nullptr)
            rear = nullptr;
        int value = temp->data;
        delete temp;
        return value;
    }

    int getFront() {
        if (front == nullptr) {
            cout << "Queue is Empty\n";
            return -1;
        }
        return front->data;
    }

    bool isEmpty() {
        return front == nullptr;
    }
};

int main() {
    Queue queue;
    queue.enqueue(10);
    queue.enqueue(20);
    queue.enqueue(30);

    cout << "Front element is: " << queue.getFront() << endl;
    cout << "Dequeued element is: " << queue.dequeue() << endl;
    cout << "Front element is: " << queue.getFront() << endl;

    return 0;
}
```
 ### Explanation:
 -  The Queue class uses a linked list to store elements.
 -  The dequeue method removes the front element from the queue.
 -  The getFront method returns the front element without removing it.
 -  The isEmpty method checks if the queue is empty.

 # Example 4: Finding the Middle of a Linked List

 **Scenario:** You are analyzing a linked list to find its middle element for some processing tasks.
 
 **Task:** Implement a function to find the middle element of a singly linked list in C+

 ## Example:
 ```cpp
 #include <iostream>
using namespace std;

class Node {
public:
    int data;
    Node* next;

    Node(int value) : data(value), next(nullptr) {}
};

Node* findMiddle(Node* head) {
    if (head == nullptr) return nullptr;
    Node* slow = head;
    Node* fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}

void printList(Node* head) {
    while (head != nullptr) {
        cout << head->data << " ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    cout << "Linked List: ";
    printList(head);

    Node* middle = findMiddle(head);
    if (middle != nullptr)
        cout << "Middle element is: " << middle->data << endl;
    else
        cout << "The list is empty\n";

    return 0;
}
```
### Explanation:
-  The findMiddIe function uses the two-pointer technique to find the middle of the linked list.
-  The slow pointer moves one step at a time, while the fast pointer moves two steps at a time.
-  When the fast pointer reaches the end, the slow pointer will be at the middle.

# Example 5: Implementing Merge Sort

**Scenario:** You are tasked with implementing a sorting algorithm for large datasets that needs to be efficient in terms of time complexity.

**Task:** Implement the merge sort algorithm in C++.

## Example:
```cpp
#include <iostream>
using namespace std;

void merge(int array[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    int* L = new int[n1];
    int* R = new int[n2];

    for (int i = 0; i < n1; ++i)
        L[i] = array[left + i];
    for (int i = 0; i < n2; ++i)
        R[i] = array[mid + 1 + i];

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j])
            array[k++] = L[i++];
        else
            array[k++] = R[j++];
    }

    while (i < n1)
        array[k++] = L[i++];

    while (j < n2)
        array[k++] = R[j++];

    delete[] L;
    delete[] R;
}

void mergeSort(int array[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(array, left, mid);
        mergeSort(array, mid + 1, right);
        merge(array, left, mid, right);
    }
}

void printArray(int array[], int size) {
    for (int i = 0; i < size; ++i)
        cout << array[i] << " ";
    cout << endl;
}

int main() {
    int array[] = {12, 11, 13, 5, 6, 7};
    int size = sizeof(array) / sizeof(array[0]);

    cout << "Given array is \n";
    printArray(array, size);

    mergeSort(array, 0, size - 1);

    cout << "Sorted array is \n";
    printArray(array, size);

    return 0;
}
```
### Explanation:
#### Array: 
- A sequence of elements stored in contiguous memory locations. In this example, arrays are used to store and sort elements.

#### Merge Function:
- Purpose: Merges two sorted subarrays back into the original array in sorted order.
- Process: Creates temporary arrays L and R to hold elements from the two subarrays, then merges them back into the original array.
####MergeSort Function:
- Purpose: Recursively splits the array into smaller subarrays until each subarray has one element, then merges them back together.
- Process: Finds the middle point, recursively sorts the left and right halves, and merges them using the merge function.
#### Main Function:
- Purpose: Demonstrates the merge sort.
- Process: Initializes an array, prints the original array, sorts it using mergeSort, and prints the sorted array.

# Example 6: Binary Search
**Question:** Implement binary search algorithm in Java.

**Scenario:** You need to implement a search algorithm to efficiently find an element in a sorted array.

**Task:** Implement the binary search algorithm in Java.

## Implementation:
```java
public class BinarySearchExample {

    // Method to perform binary search
    public static int binarySearch(int[] arr, int target) {
        int left = 0; 
        int right = arr.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            // Check if the target is present at mid
            if (arr[mid] == target) {
                return mid; // Target found
            }

            // If target is greater, ignore the left half
            if (arr[mid] < target) {
                left = mid + 1;
            } 
            // If target is smaller, ignore the right half
            else {
                right = mid - 1;
            }
        }

        // Target not found
        return -1;
    }

    public static void main(String[] args) {
        int[] arr = {2, 3, 4, 10, 40};
        int target = 10;

        int result = binarySearch(arr, target);
        if (result != -1) {
            System.out.println("Element found at index " + result);
        } else {
            System.out.println("Element not found in array");
        }
    }
}
```
## Explanation:
#### Binary Search Method:

- Parameters: Takes a sorted array arr and the target value to be searched.
-**Variables:
   - left: Starting index of the array (initially set to 0).

   - right: Ending index of the array (initially set to arr.length - 1).

#### Process:

- The while loop runs as long as left is less than or equal to right.
- Mid Calculation: int mid = left + (right - left) / 2; calculates the middle index to avoid overflow.

#### Check Mid Value:
- If arr[mid] equals the target, the target is found, and the index mid is returned.
- If arr[mid] is less than the target, search in the right half by updating left to mid + 1.
- If arr[mid] is greater than the target, search in the left half by updating right to mid - 1.
#### Return: If the target is not found, -1 is returned.

# Example 7: Implementing Bubble Sort in Java

**Question:** Implement the bubble sort algorithm in Java.

**Explanation:** Bubble sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. It passes through the list multiple times until no swaps are needed, indicating that the list is sorted.

## Java Implementation:
```java
public class BubbleSortExample {

    // Method to perform bubble sort
    public static void bubbleSort(int[] arr) {
        int n = arr.length; // Get the length of the array
        boolean swapped;    // Flag to track if any elements were swapped

        do {
            swapped = false; // Assume no swaps are needed initially

            // Iterate through the array and perform swaps
            for (int i = 1; i < n; i++) {
                if (arr[i - 1] > arr[i]) {
                    // Swap arr[i-1] and arr[i]
                    int temp = arr[i - 1];
                    arr[i - 1] = arr[i];
                    arr[i] = temp;
                    swapped = true; // Set swapped flag to true
                }
            }

            n--; // Decrease the array length after each pass
        } while (swapped); // Repeat until no swaps are needed
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};

        System.out.println("Array before sorting:");
        printArray(arr);

        bubbleSort(arr);

        System.out.println("Array after sorting:");
        printArray(arr);
    }

    // Utility method to print the elements of an array
    public static void printArray(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }
}
```

## Explanation:

#### Bubble Sort Method (bubbleSort):
- Purpose: Sorts an array arr in ascending order using the bubble sort algorithm

-**Variables:
  -n: Holds the current length of the array.

  -swapped: Boolean flag to indicate if any elements were swapped during 
   a pass through the array.

#### Process:
- The do-while loop executes at least once and continues as long as swapped is true, indicating that at least one swap occurred in the previous pass.
- Inside the loop, the for loop iterates through the array from index 1 to n-1.
- If arr[i-1] is greater than arr[i], the elements are swapped, and swapped is set to true.
- After each complete pass through the array (for loop), n is decremented to shorten the effective length of the array for subsequent passes.

#### Main Method:
- Initializes an array arr with unsorted elements.
- Prints the array before sorting.
- Calls bubbleSort to sort the array.
- Prints the array after sorting.

#### Utility Method (printArray):
-Prints the elements of an array for display purposes.












 
 
  
  
